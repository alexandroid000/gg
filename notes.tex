\documentclass[twoside]{article}

\usepackage{graphicx,hyperref}
\usepackage[utf8x]{inputenc}
\usepackage{microtype}
\usepackage{colortbl,arydshln} % color and dashed lines in arrays
\usepackage[charter]{mathdesign}
\usepackage{berasans,beramono}
\usepackage[mathcal]{euscript}
\usepackage[all]{xy}
\usepackage{mathtools}
\usepackage{amsthm}
\usepackage{xspace}
\usepackage{tikz}

\usepackage{enumitem}
\setlist[enumerate]{leftmargin=*}
\setlist[itemize]{leftmargin=*}

\usepackage{todonotes}
%\usepackage[left]{showlabels}

\theoremstyle{plain}
\newtheorem{lemma}{Lemma}[section]


\theoremstyle{definition}
\newtheorem{definition}{Definition}[section]

\def\E{\operatorname{E}}
\renewcommand{\exp}[1]{\operatorname{exp}\left\{#1\right\}}
\def\qeq{\overset{?}{=}}

\def\tsc#1{\textsc{#1}}

\def\cc#1{\textbf{#1}}

\def\complement#1{\overline{#1}}

\def\placeholder{\makebox[1ex]{\textbf{$\cdot$}}}

\def\mpreduces{\mathrel{\leq_m^p}}

\makeatletter

% ---- SYMBOLS ----
\let\e\varepsilon
%
%  I give up.  These are in the wrong font, but my kludged versions 
%  LOOK like kludges, especially \Z, \Q, and \C.
%
\def\Real{\mathbb{R}}
\def\Proj{\mathbb{P}}
\def\Hyper{\mathbb{H}}
\def\Integer{\mathbb{Z}}
\def\Natural{\mathbb{N}}
\def\Complex{\mathbb{C}}
\def\Rational{\mathbb{Q}}

\let\N\Natural
\let\Q\Rational
\let\R\Real
\let\Z\Integer
\def\Rd{\Real^d}
\def\RP{\Real\Proj}
\def\CP{\Complex\Proj}

% ---- OPERATORS (requires amsmath) ----
\def\aff{\operatorname{aff}}		
\def\area{\operatorname{area}}
\def\argmax{\operatornamewithlimits{arg\,max}}
\def\argmin{\operatornamewithlimits{arg\,min}}
\def\Aut{\operatorname{Aut}}		% Automorphism group
\def\card{\operatorname{card}}	% cardinality, deprecated for \abs
\def\conv{\operatorname{conv}}	
\def\E{\operatorname{E}}			% Expectation: $\E[X]$ (like \Pr)
\def\EE{\operatornamewithlimits{E}}
\def\Hom{\operatorname{Hom}}		% Homomorphism group
\def\id{\operatorname{id}}		% identity
\def\im{\operatorname{im}}		% image
\def\lcm{\operatorname{lcm}}
\def\lfs{\operatorname{lfs}}		% local feature size
\def\poly{\operatorname{poly}}
\def\polylog{\operatorname{polylog}}
\def\rank{\operatorname{rank}}
\def\rel{\operatorname{rel\,}}	% relative (interior, boundary, etc.)
\def\sgn{\operatorname{sgn}}
\def\vol{\operatorname{vol}}		% volume

\def\fp#1{^{\underline{#1}}}		% falling powers: $n\fp{d}$
\def\rp#1{^{\overline{#1}}}		% rising powers:  $n\rp{d}$


% --- Darts and fences ---
% less nice replacements for stmaryrd characters
\@ifundefined{shortrightarrow}{\let\shortrightarrow\rightarrow}{}
\@ifundefined{shortleftarrow}{\let\shortleftarrow\leftarrow}{}
\@ifundefined{shortuparrow}{\let\shortuparrow\uparrow}{}
\@ifundefined{shortdownarrow}{\let\shortdownarrow\downarrow}{}

\def\arcto{\mathord\shortrightarrow}
\def\arcfrom{\mathord\shortleftarrow}
\def\arc#1#2{#1\arcto#2}
\def\cra#1#2{#1\mathord\shortleftarrow#2}
\def\fence#1#2{#1\mathord\shortuparrow#2}
\def\ecnef#1#2{#1\mathord\shortdownarrow#2}

% --- Cheap displaystyle operators ---
\def\Frac#1#2{{\displaystyle\frac{#1}{#2}}}
\def\Sum{\sum\limits}
\def\Prod{\prod\limits}
\def\Union{\bigcup\limits}
\def\Inter{\bigcap\limits}
\def\Lor{\bigvee\limits}
\def\Land{\bigwedge\limits}
\def\Lim{\lim\limits}
\def\Max{\max\limits}
\def\Min{\min\limits}

% ---- RELATORS ----
\def\deq{\stackrel{\scriptscriptstyle\triangle}{=}}	% Use := instead.
\def\into{\DOTSB\hookrightarrow}		% = one-to-one
\def\onto{\DOTSB\twoheadrightarrow}
\def\inonto{\DOTSB\lhook\joinrel\twoheadrightarrow}
\def\from{\leftarrow}
\def\tofrom{\leftrightarrow}
\def\mapsfrom{\mathrel{\reflectbox{$\mapsto$}}}
\def\longmapsfrom{\mathrel{\reflectbox{$\longmapsto$}}}

% ---- DELIMITER PAIRS ----
\def\floor#1{\lfloor #1 \rfloor}
\def\ceil#1{\lceil #1 \rceil}
\def\seq#1{\langle #1 \rangle}
\def\set#1{\{ #1 \}}
\def\abs#1{\mathopen| #1 \mathclose|}			% use instead of $|x|$ 
\def\norm#1{\mathopen\| #1 \mathclose\|}		% use instead of $\|x\|$ 
\def\indic#1{\big[#1\big]}		% indicator variable; Iverson notation
								% e.g., Kronecker delta = [x=0]

% --- Self-scaling delmiter pairs ---
\def\Floor#1{\left\lfloor #1 \right\rfloor}
\def\Ceil#1{\left\lceil #1 \right\rceil}
\def\Seq#1{\left\langle #1 \right\rangle}
\def\Set#1{\left\{ #1 \right\}}
\def\Abs#1{\left| #1 \right|}
\def\Card#1{\left| #1 \right|}
\def\Norm#1{\left\| #1 \right\|}
\def\Paren#1{\left( #1 \right)}		% need better macro name!
\def\Brack#1{\left[ #1 \right]}		% need better macro name!
\def\Indic#1{\left[ #1 \right]}		% indicator variable; Iverson notation

%
%  Macros to typeset sets like {foo|bar} with all three delimiters
%  correctly scaled to fit.  What I *really* want is a \middle macro
%  that acts just like \left and \right.  Grumble.
%
\def\Bigbar#1{\mathrel{\left|\vphantom{#1}\right.\n@space}}
\def\Setbar#1#2{\Set{#1 \Bigbar{#1 #2} #2}}
\def\Seqbar#1#2{\Seq{#1 \Bigbar{#1 #2} #2}}
\def\Brackbar#1#2{\Brack{#1 \Bigbar{#1 #2} #2}}


\makeatother

\def\RuleSeq{\mathrm{RuleSeq}\xspace}
\DeclareMathOperator{\attach}{attach}
\DeclareMathOperator{\relabel}{relabel}
\DeclareMathOperator{\detach}{detach}

\def\Graphs{\mathcal{G}\xspace}
\def\Concepts{\mathcal{C}\xspace}
\def\Hypotheses{\mathcal{H}\xspace}

\newcommand{\step}[1]{\xrightarrow{#1}}

\begin{document}
\section{Idea for PAC-learning}
Let $\RuleSeq_\Sigma$ be a sequence of rules over a finite set of labels $\Sigma$, where a rule is one of the following: 
\[ \attach(A,B),\quad, \relabel(A,B),\,\text{or}\quad \detach(A, B) \] for some $A,B \in \Sigma$.

Let $\Graphs_{n,\Sigma}$ denote the set of all pairs $(G,\ell)$ where $G$ is a graph on vertex set $[n]$ and $\ell : [n] \to \Sigma$ assigns a label to each vertex. Let $\Graphs_{\Sigma} = \cup_{n\geq 0} \Graphs_{n,\Sigma}$.

For each rule sequence $S\in \RuleSeq$, there is a corresponding step relation $\step{S}$ such that
\[ G \step{S} G' \] if and only $G$ differs from $G'$ by a single application of the first rule in $S$ that can be applied, to the lexicographically first vertex or vertices to which it can be applied. 

For any $S\in \RuleSeq$, we define the function $f_S : \Graphs_{\Sigma} \to \Set{0,1}$ as follows:
\[ f_S(G) = \begin{cases}
    1 &\,\text{if after $100\Card{V(G)}$ steps of $\step{S}$ starting with $G$ a steady state is reached in which the graph is connected}\\
    0 &\,\text{otherwise}
  \end{cases} \]

Our concept class will be $\Concepts_\Sigma = \Setbar{f_S}{S\in \RuleSeq_\Sigma}$. Our hypothesis class will be $\Hypotheses_{\Sigma} = \Concepts_\Sigma$.

We will be interested in the following question: Can we PAC-learn (or efficiently PAC-learn) a hypothesis $h \in \Hypotheses$ given equivalence queries and memebership queries?
\end{document}